// Generated by AshTypescript
// Do not edit this file manually



export type UUID = string;
export type UtcDateTime = string;
export type UtcDateTimeUsec = string;

// GonguGroupsGroup Schema
export type GonguGroupsGroupResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description" | "creatorId";
  id: UUID;
  name: string;
  description: string | null;
  creatorId: UUID;
};



// GonguGroupsGroupMembership Schema
export type GonguGroupsGroupMembershipResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "groupId" | "role" | "status" | "invitedById";
  id: UUID;
  userId: UUID;
  groupId: UUID;
  role: "admin" | "member";
  status: "active" | "pending" | "inactive";
  invitedById: UUID | null;
};



// GonguGroupsInvitation Schema
export type GonguGroupsInvitationResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "code" | "createdById" | "usedById" | "status" | "expiresAt" | "usedAt" | "groupId";
  id: UUID;
  code: string;
  createdById: UUID;
  usedById: UUID | null;
  status: "pending" | "accepted" | "expired";
  expiresAt: UtcDateTimeUsec;
  usedAt: UtcDateTimeUsec | null;
  groupId: UUID;
};



// GonguGroupsCalendar Schema
export type GonguGroupsCalendarResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description" | "color" | "timezone" | "visibility" | "ownerId" | "groupId";
  id: UUID;
  name: string;
  description: string | null;
  color: string | null;
  timezone: string | null;
  visibility: "public" | "private";
  ownerId: UUID;
  groupId: UUID | null;
};



// GonguGroupsEvent Schema
export type GonguGroupsEventResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "startTime" | "endTime" | "allDay" | "location" | "calendarId" | "recurrenceRule" | "status" | "createdById";
  id: UUID;
  title: string;
  description: string | null;
  startTime: UtcDateTime;
  endTime: UtcDateTime;
  allDay: boolean;
  location: string | null;
  calendarId: UUID;
  recurrenceRule: string | null;
  status: "confirmed" | "tentative" | "cancelled";
  createdById: UUID;
};









export type GonguGroupsGroupFilterInput = {
  and?: Array<GonguGroupsGroupFilterInput>;
  or?: Array<GonguGroupsGroupFilterInput>;
  not?: Array<GonguGroupsGroupFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  creatorId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};
export type GonguGroupsGroupMembershipFilterInput = {
  and?: Array<GonguGroupsGroupMembershipFilterInput>;
  or?: Array<GonguGroupsGroupMembershipFilterInput>;
  not?: Array<GonguGroupsGroupMembershipFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  groupId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  role?: {
    eq?: "admin" | "member";
    notEq?: "admin" | "member";
    in?: Array<"admin" | "member">;
  };

  status?: {
    eq?: "active" | "pending" | "inactive";
    notEq?: "active" | "pending" | "inactive";
    in?: Array<"active" | "pending" | "inactive">;
  };

  invitedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};
export type GonguGroupsInvitationFilterInput = {
  and?: Array<GonguGroupsInvitationFilterInput>;
  or?: Array<GonguGroupsInvitationFilterInput>;
  not?: Array<GonguGroupsInvitationFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  code?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  usedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  status?: {
    eq?: "pending" | "accepted" | "expired";
    notEq?: "pending" | "accepted" | "expired";
    in?: Array<"pending" | "accepted" | "expired">;
  };

  expiresAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  usedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  groupId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};
export type GonguGroupsCalendarFilterInput = {
  and?: Array<GonguGroupsCalendarFilterInput>;
  or?: Array<GonguGroupsCalendarFilterInput>;
  not?: Array<GonguGroupsCalendarFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  color?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  timezone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  visibility?: {
    eq?: "public" | "private";
    notEq?: "public" | "private";
    in?: Array<"public" | "private">;
  };

  ownerId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  groupId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};
export type GonguGroupsEventFilterInput = {
  and?: Array<GonguGroupsEventFilterInput>;
  or?: Array<GonguGroupsEventFilterInput>;
  not?: Array<GonguGroupsEventFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  startTime?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  endTime?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  allDay?: {
    eq?: boolean;
    notEq?: boolean;
  };

  location?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  calendarId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  recurrenceRule?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  status?: {
    eq?: "confirmed" | "tentative" | "cancelled";
    notEq?: "confirmed" | "tentative" | "cancelled";
    in?: Array<"confirmed" | "tentative" | "cancelled">;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};


// Utility Types

// Resource schema constraint
type TypedSchema = {
  __type: "Resource" | "TypedStruct" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : NonNullable<T[K]> extends TypedSchema
        ? UnifiedFieldSelection<NonNullable<T[K]>>[]
        : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends TypedSchema
              ? null extends T[K]
                ? InferResult<NonNullable<T[K]>, Field[K]> | null
                : InferResult<NonNullable<T[K]>, Field[K]>
              : never
          : never;
      }
    : never;

type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[],
> = UnionToIntersection<
  {
    [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
  }[number]
>;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call
 * @example
 * const error: AshRpcError = { type: "validation_error", message: "Something went wrong" }
 */
export type AshRpcError = {
  type: string;
  message: string;
  field?: string;
  fieldPath?: string;
  details?: Record<string, any>;
}





// Helper Functions

/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}





export type ListGroupsFields = UnifiedFieldSelection<GonguGroupsGroupResourceSchema>[];

type InferListGroupsResult<
  Fields extends ListGroupsFields,
> = {
  results: Array<InferResult<GonguGroupsGroupResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<GonguGroupsGroupResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListGroupsResult<Fields extends ListGroupsFields> = | { success: true; data: InferListGroupsResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listGroups<Fields extends ListGroupsFields>(
  config: {
  fields: Fields;
  filter?: GonguGroupsGroupFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListGroupsResult<Fields>> {
  const payload = {
    action: "list_groups",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListGroupsResult<Fields>;
}


export type ValidateListGroupsResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListGroups(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListGroupsResult> {
  const payload = {
    action: "list_groups"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListGroupsResult;
}


export type CreateGroupInput = {
  name: string;
  description?: string | null;
};

export type CreateGroupValidationErrors = {
  name?: string[];
  description?: string[];
};

export type CreateGroupFields = UnifiedFieldSelection<GonguGroupsGroupResourceSchema>[];

type InferCreateGroupResult<
  Fields extends CreateGroupFields,
> = InferResult<GonguGroupsGroupResourceSchema, Fields>;

export type CreateGroupResult<Fields extends CreateGroupFields> = | { success: true; data: InferCreateGroupResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createGroup<Fields extends CreateGroupFields>(
  config: {
  input: CreateGroupInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateGroupResult<Fields>> {
  const payload = {
    action: "create_group",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateGroupResult<Fields>;
}


export type ValidateCreateGroupResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateGroup(
  config: {
  input: CreateGroupInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateCreateGroupResult> {
  const payload = {
    action: "create_group",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateGroupResult;
}


export type GetGroupFields = UnifiedFieldSelection<GonguGroupsGroupResourceSchema>[];

type InferGetGroupResult<
  Fields extends GetGroupFields,
> = {
  results: Array<InferResult<GonguGroupsGroupResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<GonguGroupsGroupResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type GetGroupResult<Fields extends GetGroupFields> = | { success: true; data: InferGetGroupResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getGroup<Fields extends GetGroupFields>(
  config: {
  fields: Fields;
  filter?: GonguGroupsGroupFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetGroupResult<Fields>> {
  const payload = {
    action: "get_group",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetGroupResult<Fields>;
}


export type ValidateGetGroupResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetGroup(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateGetGroupResult> {
  const payload = {
    action: "get_group"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetGroupResult;
}


export type UpdateGroupInput = {
  name: string;
  description?: string | null;
};

export type UpdateGroupValidationErrors = {
  name?: string[];
  description?: string[];
};

export type UpdateGroupFields = UnifiedFieldSelection<GonguGroupsGroupResourceSchema>[];

type InferUpdateGroupResult<
  Fields extends UpdateGroupFields,
> = InferResult<GonguGroupsGroupResourceSchema, Fields>;

export type UpdateGroupResult<Fields extends UpdateGroupFields> = | { success: true; data: InferUpdateGroupResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateGroup<Fields extends UpdateGroupFields>(
  config: {
  primaryKey: UUID;
  input: UpdateGroupInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateGroupResult<Fields>> {
  const payload = {
    action: "update_group",
    primaryKey: config.primaryKey,
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateGroupResult<Fields>;
}


export type ValidateUpdateGroupResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateGroup(
  config: {
  primaryKey: string;
  input: UpdateGroupInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateUpdateGroupResult> {
  const payload = {
    action: "update_group",
    primaryKey: config.primaryKey,
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateGroupResult;
}



export type DeleteGroupResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteGroup(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DeleteGroupResult> {
  const payload = {
    action: "delete_group",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteGroupResult;
}


export type ValidateDeleteGroupResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteGroup(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateDeleteGroupResult> {
  const payload = {
    action: "delete_group",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteGroupResult;
}


export type ListMembershipsFields = UnifiedFieldSelection<GonguGroupsGroupMembershipResourceSchema>[];

type InferListMembershipsResult<
  Fields extends ListMembershipsFields,
> = {
  results: Array<InferResult<GonguGroupsGroupMembershipResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<GonguGroupsGroupMembershipResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListMembershipsResult<Fields extends ListMembershipsFields> = | { success: true; data: InferListMembershipsResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listMemberships<Fields extends ListMembershipsFields>(
  config: {
  fields: Fields;
  filter?: GonguGroupsGroupMembershipFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListMembershipsResult<Fields>> {
  const payload = {
    action: "list_memberships",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListMembershipsResult<Fields>;
}


export type ValidateListMembershipsResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListMemberships(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListMembershipsResult> {
  const payload = {
    action: "list_memberships"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListMembershipsResult;
}


export type InviteToGroupInput = {
  userId: UUID;
  groupId: UUID;
  invitedById?: UUID | null;
};

export type InviteToGroupValidationErrors = {
  userId?: string[];
  groupId?: string[];
  invitedById?: string[];
};

export type InviteToGroupFields = UnifiedFieldSelection<GonguGroupsGroupMembershipResourceSchema>[];

type InferInviteToGroupResult<
  Fields extends InviteToGroupFields,
> = InferResult<GonguGroupsGroupMembershipResourceSchema, Fields>;

export type InviteToGroupResult<Fields extends InviteToGroupFields> = | { success: true; data: InferInviteToGroupResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function inviteToGroup<Fields extends InviteToGroupFields>(
  config: {
  input: InviteToGroupInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InviteToGroupResult<Fields>> {
  const payload = {
    action: "invite_to_group",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as InviteToGroupResult<Fields>;
}


export type ValidateInviteToGroupResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateInviteToGroup(
  config: {
  input: InviteToGroupInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateInviteToGroupResult> {
  const payload = {
    action: "invite_to_group",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateInviteToGroupResult;
}


export type JoinWithInvitationInput = {
  inviteCode: string;
};

export type JoinWithInvitationValidationErrors = {
  inviteCode?: string[];
};

export type JoinWithInvitationFields = UnifiedFieldSelection<GonguGroupsGroupMembershipResourceSchema>[];

type InferJoinWithInvitationResult<
  Fields extends JoinWithInvitationFields,
> = InferResult<GonguGroupsGroupMembershipResourceSchema, Fields>;

export type JoinWithInvitationResult<Fields extends JoinWithInvitationFields> = | { success: true; data: InferJoinWithInvitationResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function joinWithInvitation<Fields extends JoinWithInvitationFields>(
  config: {
  input: JoinWithInvitationInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<JoinWithInvitationResult<Fields>> {
  const payload = {
    action: "join_with_invitation",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as JoinWithInvitationResult<Fields>;
}


export type ValidateJoinWithInvitationResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateJoinWithInvitation(
  config: {
  input: JoinWithInvitationInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateJoinWithInvitationResult> {
  const payload = {
    action: "join_with_invitation",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateJoinWithInvitationResult;
}


export type UpdateMemberRoleInput = {
  role?: "admin" | "member";
};

export type UpdateMemberRoleValidationErrors = {
  role?: string[];
};

export type UpdateMemberRoleFields = UnifiedFieldSelection<GonguGroupsGroupMembershipResourceSchema>[];

type InferUpdateMemberRoleResult<
  Fields extends UpdateMemberRoleFields,
> = InferResult<GonguGroupsGroupMembershipResourceSchema, Fields>;

export type UpdateMemberRoleResult<Fields extends UpdateMemberRoleFields> = | { success: true; data: InferUpdateMemberRoleResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateMemberRole<Fields extends UpdateMemberRoleFields>(
  config: {
  primaryKey: UUID;
  input: UpdateMemberRoleInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateMemberRoleResult<Fields>> {
  const payload = {
    action: "update_member_role",
    primaryKey: config.primaryKey,
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateMemberRoleResult<Fields>;
}


export type ValidateUpdateMemberRoleResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateMemberRole(
  config: {
  primaryKey: string;
  input: UpdateMemberRoleInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateUpdateMemberRoleResult> {
  const payload = {
    action: "update_member_role",
    primaryKey: config.primaryKey,
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateMemberRoleResult;
}



export type LeaveGroupResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function leaveGroup(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<LeaveGroupResult> {
  const payload = {
    action: "leave_group",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as LeaveGroupResult;
}


export type ValidateLeaveGroupResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateLeaveGroup(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateLeaveGroupResult> {
  const payload = {
    action: "leave_group",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateLeaveGroupResult;
}


export type ListInvitationsFields = UnifiedFieldSelection<GonguGroupsInvitationResourceSchema>[];

type InferListInvitationsResult<
  Fields extends ListInvitationsFields,
> = {
  results: Array<InferResult<GonguGroupsInvitationResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<GonguGroupsInvitationResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListInvitationsResult<Fields extends ListInvitationsFields> = | { success: true; data: InferListInvitationsResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listInvitations<Fields extends ListInvitationsFields>(
  config: {
  fields: Fields;
  filter?: GonguGroupsInvitationFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListInvitationsResult<Fields>> {
  const payload = {
    action: "list_invitations",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListInvitationsResult<Fields>;
}


export type ValidateListInvitationsResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListInvitations(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListInvitationsResult> {
  const payload = {
    action: "list_invitations"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListInvitationsResult;
}


export type CreateInvitationInput = {
  groupId: UUID;
};

export type CreateInvitationValidationErrors = {
  groupId?: string[];
};

export type CreateInvitationFields = UnifiedFieldSelection<GonguGroupsInvitationResourceSchema>[];

type InferCreateInvitationResult<
  Fields extends CreateInvitationFields,
> = InferResult<GonguGroupsInvitationResourceSchema, Fields>;

export type CreateInvitationResult<Fields extends CreateInvitationFields> = | { success: true; data: InferCreateInvitationResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createInvitation<Fields extends CreateInvitationFields>(
  config: {
  input: CreateInvitationInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateInvitationResult<Fields>> {
  const payload = {
    action: "create_invitation",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateInvitationResult<Fields>;
}


export type ValidateCreateInvitationResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateInvitation(
  config: {
  input: CreateInvitationInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateCreateInvitationResult> {
  const payload = {
    action: "create_invitation",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateInvitationResult;
}


export type ListCalendarsFields = UnifiedFieldSelection<GonguGroupsCalendarResourceSchema>[];

type InferListCalendarsResult<
  Fields extends ListCalendarsFields,
> = {
  results: Array<InferResult<GonguGroupsCalendarResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<GonguGroupsCalendarResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListCalendarsResult<Fields extends ListCalendarsFields> = | { success: true; data: InferListCalendarsResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listCalendars<Fields extends ListCalendarsFields>(
  config: {
  fields: Fields;
  filter?: GonguGroupsCalendarFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListCalendarsResult<Fields>> {
  const payload = {
    action: "list_calendars",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListCalendarsResult<Fields>;
}


export type ValidateListCalendarsResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListCalendars(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListCalendarsResult> {
  const payload = {
    action: "list_calendars"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListCalendarsResult;
}


export type GetCalendarInput = {
  id: UUID;
};

export type GetCalendarValidationErrors = {
  id?: string[];
};

export type GetCalendarFields = UnifiedFieldSelection<GonguGroupsCalendarResourceSchema>[];

type InferGetCalendarResult<
  Fields extends GetCalendarFields,
> = InferResult<GonguGroupsCalendarResourceSchema, Fields> | null;

export type GetCalendarResult<Fields extends GetCalendarFields> = | { success: true; data: InferGetCalendarResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getCalendar<Fields extends GetCalendarFields>(
  config: {
  input: GetCalendarInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetCalendarResult<Fields>> {
  const payload = {
    action: "get_calendar",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetCalendarResult<Fields>;
}


export type ValidateGetCalendarResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetCalendar(
  config: {
  input: GetCalendarInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateGetCalendarResult> {
  const payload = {
    action: "get_calendar",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetCalendarResult;
}


export type CreateCalendarInput = {
  name: string;
  description?: string | null;
  color?: string | null;
  timezone?: string | null;
  visibility?: "public" | "private";
  groupId?: UUID | null;
};

export type CreateCalendarValidationErrors = {
  name?: string[];
  description?: string[];
  color?: string[];
  timezone?: string[];
  visibility?: string[];
  groupId?: string[];
};

export type CreateCalendarFields = UnifiedFieldSelection<GonguGroupsCalendarResourceSchema>[];

type InferCreateCalendarResult<
  Fields extends CreateCalendarFields,
> = InferResult<GonguGroupsCalendarResourceSchema, Fields>;

export type CreateCalendarResult<Fields extends CreateCalendarFields> = | { success: true; data: InferCreateCalendarResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createCalendar<Fields extends CreateCalendarFields>(
  config: {
  input: CreateCalendarInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCalendarResult<Fields>> {
  const payload = {
    action: "create_calendar",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateCalendarResult<Fields>;
}


export type ValidateCreateCalendarResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateCalendar(
  config: {
  input: CreateCalendarInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateCreateCalendarResult> {
  const payload = {
    action: "create_calendar",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateCalendarResult;
}


export type UpdateCalendarInput = {
  name: string;
  description?: string | null;
  color?: string | null;
  timezone?: string | null;
  visibility?: "public" | "private";
};

export type UpdateCalendarValidationErrors = {
  name?: string[];
  description?: string[];
  color?: string[];
  timezone?: string[];
  visibility?: string[];
};

export type UpdateCalendarFields = UnifiedFieldSelection<GonguGroupsCalendarResourceSchema>[];

type InferUpdateCalendarResult<
  Fields extends UpdateCalendarFields,
> = InferResult<GonguGroupsCalendarResourceSchema, Fields>;

export type UpdateCalendarResult<Fields extends UpdateCalendarFields> = | { success: true; data: InferUpdateCalendarResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateCalendar<Fields extends UpdateCalendarFields>(
  config: {
  primaryKey: UUID;
  input: UpdateCalendarInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateCalendarResult<Fields>> {
  const payload = {
    action: "update_calendar",
    primaryKey: config.primaryKey,
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateCalendarResult<Fields>;
}


export type ValidateUpdateCalendarResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateCalendar(
  config: {
  primaryKey: string;
  input: UpdateCalendarInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateUpdateCalendarResult> {
  const payload = {
    action: "update_calendar",
    primaryKey: config.primaryKey,
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateCalendarResult;
}



export type DeleteCalendarResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteCalendar(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DeleteCalendarResult> {
  const payload = {
    action: "delete_calendar",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteCalendarResult;
}


export type ValidateDeleteCalendarResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteCalendar(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateDeleteCalendarResult> {
  const payload = {
    action: "delete_calendar",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteCalendarResult;
}


export type ListEventsFields = UnifiedFieldSelection<GonguGroupsEventResourceSchema>[];

type InferListEventsResult<
  Fields extends ListEventsFields,
> = {
  results: Array<InferResult<GonguGroupsEventResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
} | {
  results: Array<InferResult<GonguGroupsEventResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
};

export type ListEventsResult<Fields extends ListEventsFields> = | { success: true; data: InferListEventsResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listEvents<Fields extends ListEventsFields>(
  config: {
  fields: Fields;
  filter?: GonguGroupsEventFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListEventsResult<Fields>> {
  const payload = {
    action: "list_events",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as ListEventsResult<Fields>;
}


export type ValidateListEventsResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListEvents(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListEventsResult> {
  const payload = {
    action: "list_events"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateListEventsResult;
}


export type GetEventInput = {
  id: UUID;
};

export type GetEventValidationErrors = {
  id?: string[];
};

export type GetEventFields = UnifiedFieldSelection<GonguGroupsEventResourceSchema>[];

type InferGetEventResult<
  Fields extends GetEventFields,
> = InferResult<GonguGroupsEventResourceSchema, Fields> | null;

export type GetEventResult<Fields extends GetEventFields> = | { success: true; data: InferGetEventResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getEvent<Fields extends GetEventFields>(
  config: {
  input: GetEventInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetEventResult<Fields>> {
  const payload = {
    action: "get_event",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as GetEventResult<Fields>;
}


export type ValidateGetEventResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetEvent(
  config: {
  input: GetEventInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateGetEventResult> {
  const payload = {
    action: "get_event",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateGetEventResult;
}


export type CreateEventInput = {
  title: string;
  description?: string | null;
  startTime: UtcDateTime;
  endTime: UtcDateTime;
  allDay?: boolean;
  location?: string | null;
  calendarId: UUID;
  recurrenceRule?: string | null;
  status?: "confirmed" | "tentative" | "cancelled";
};

export type CreateEventValidationErrors = {
  title?: string[];
  description?: string[];
  startTime?: string[];
  endTime?: string[];
  allDay?: string[];
  location?: string[];
  calendarId?: string[];
  recurrenceRule?: string[];
  status?: string[];
};

export type CreateEventFields = UnifiedFieldSelection<GonguGroupsEventResourceSchema>[];

type InferCreateEventResult<
  Fields extends CreateEventFields,
> = InferResult<GonguGroupsEventResourceSchema, Fields>;

export type CreateEventResult<Fields extends CreateEventFields> = | { success: true; data: InferCreateEventResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createEvent<Fields extends CreateEventFields>(
  config: {
  input: CreateEventInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateEventResult<Fields>> {
  const payload = {
    action: "create_event",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as CreateEventResult<Fields>;
}


export type ValidateCreateEventResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateEvent(
  config: {
  input: CreateEventInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateCreateEventResult> {
  const payload = {
    action: "create_event",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateCreateEventResult;
}


export type UpdateEventInput = {
  title: string;
  description?: string | null;
  startTime: UtcDateTime;
  endTime: UtcDateTime;
  allDay?: boolean;
  location?: string | null;
  recurrenceRule?: string | null;
  status?: "confirmed" | "tentative" | "cancelled";
};

export type UpdateEventValidationErrors = {
  title?: string[];
  description?: string[];
  startTime?: string[];
  endTime?: string[];
  allDay?: string[];
  location?: string[];
  recurrenceRule?: string[];
  status?: string[];
};

export type UpdateEventFields = UnifiedFieldSelection<GonguGroupsEventResourceSchema>[];

type InferUpdateEventResult<
  Fields extends UpdateEventFields,
> = InferResult<GonguGroupsEventResourceSchema, Fields>;

export type UpdateEventResult<Fields extends UpdateEventFields> = | { success: true; data: InferUpdateEventResult<Fields> }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateEvent<Fields extends UpdateEventFields>(
  config: {
  primaryKey: UUID;
  input: UpdateEventInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateEventResult<Fields>> {
  const payload = {
    action: "update_event",
    primaryKey: config.primaryKey,
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as UpdateEventResult<Fields>;
}


export type ValidateUpdateEventResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateEvent(
  config: {
  primaryKey: string;
  input: UpdateEventInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateUpdateEventResult> {
  const payload = {
    action: "update_event",
    primaryKey: config.primaryKey,
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateUpdateEventResult;
}



export type DeleteEventResult = | { success: true; data: {} }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function deleteEvent(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DeleteEventResult> {
  const payload = {
    action: "delete_event",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  const result = await response.json();
  return result as DeleteEventResult;
}


export type ValidateDeleteEventResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateDeleteEvent(
  config: {
  primaryKey: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateDeleteEventResult> {
  const payload = {
    action: "delete_event",
    primaryKey: config.primaryKey
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
  };

  const fetchFunction = config.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText }],
    };
  }

  const result = await response.json();
  return result as ValidateDeleteEventResult;
}


